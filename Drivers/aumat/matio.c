/** \file matio.c
 * \brief This part of the C language library iau_mat provides some  
 * functions that enables the use of MAT files generated by MATLAB.
 * The functions MLOAD and MSAVE enables the use of MAT files         
 * generated by MATLAB.                                               
 *  
 * All matrices are represented by a structure with the dimensions 
 * of the matrix and a pointer to an array of pointers to each 
 * row in the matrix. The functions using stdio can be excluded by        
 * defining the symbol NO_IO to the compiler.                       
 * 
 * References   : Brugervejledning til C/Matlab matrix bibliotek,     
 *                Appendix F i Noergaard og Torp (1993).              
 *
 * \author O. Ravn
 * \author A. Pjetursson
 * \author P.M. Noergaard
 * \author S. Torp
 * 
 * \date 26/01-1998
 * \version 1.2
 */ 
 
 /***********************************************************************
 * $Source: /home/lvmogensen/AUTcvs/repository/aumat/matio.c,v $
 * $Log: not supported by cvs2svn $
 * Revision 1.2  1998/01/26 10:21:36  or
 * Libraries updated and demomat program added
 *
 * Revision 1.1  1998/01/23 12:50:31  or
 * Matrix.c divided into 3 parts containing core, io and inv functions
 *
 * Revision 1.3  1998/01/19 09:04:08  pmn
 * Integrated with PMN's version of matrix2.c.
 *
 * Revision 1.2  1998/01/14 13:01:42  or
 * *** empty log message ***
 *
 * Revision 1.1.1.1  1997/08/12 13:58:49  or
 * Matrix Library for RealTime use
 *
 * Revision 1.3  1995/08/03  11:14:07  ap
 * "fopen" removed from matload
 *
 * Revision 1.2  1995/06/02  14:00:38  ap
 * Small updates
 *
 * Revision 1.1.1.1  1995/05/17  12:02:07  ap
 * This realtime system is initially written by P.M. Noergaard and S. Torp. This
 * new version and software structure are made by O. Ravn and A. Pjetursson.
 *
 **********************************************************************/
#include <stdlib.h>
#include <string.h>

#include "iau_mat.h"     


#define TRUE 1     ///< Definition of a basic logical value
#define FALSE 0    ///< Definition of a basic logical value
#define FOUND 1    ///< Definition of a basic logical value
#define NOTFOUND 0 ///< Definition of a basic logical value

#ifdef _OSK
  #include <modes.h>
  #include <sg_codes.h>
  #include <types.h>
  #undef stderr
  #define stderr stdout
#endif

#if IO == ON  /* I/O functions are not available in the DSP C compiler */
#include <stdio.h>
int  loadmat(FILE*, int*, char*, int*, int*, int*, float**, float**);
void savemat(FILE*,  int, char*,  int,  int,  int,  float*,  float*);
long longconv(long);           /* Internal functions, only used by  */
void matconv(int, float*);    /* The functions in this library.    */

/** \struct Fmatrix matio.c
 * \brief Matrix structure for MATLAB files
 */
typedef struct {               /* Matrix structure for MATLAB files */
	long type;   ///< Type of the variable
	long mrows;  ///< Number of rows in the variable
	long ncols;  ///< Number of columns in the variable
	long imagf;  ///< Flag to indicate if the variable format is real/imaginary
	long namlen; ///< Length of the variable name
} Fmatrix;

#endif

/// Specifies the system on which the system should run/compile
#define SYSTEM 0               /* 0 = PC, 1000 = UNIX and OS/9 */

#ifdef _OSK
  #undef SYSTEM
  #define SYSTEM 1000
#endif

#ifdef __unix
  #undef SYSTEM
  #define SYSTEM 1000
#endif


/** \fn void makelist( varlisttype *varlist, char *name, int index )
 * This function is used to make a list with all the variable
 * names entered in name
 * \param[out] *varlist Name of variable list
 * \param[in]  *name Name of variable to add to list
 * \param[in]  index Id number of the added item.
 */ 
void makelist( varlisttype *varlist, char *name, int index )
{
	varlisttype *varptr;

	varptr = varlist;
	while( varptr->next )
		varptr = (varlisttype*)varptr->next;
	strcpy( varptr->name,name );
	varptr->idnumber = index;
	varptr->status = NOTFOUND;
	varptr->next = (void*)malloc(sizeof(varlisttype));
	varptr = (varlisttype*)varptr->next;
	varptr->next = 0;
}

/** \fn void freelist( varlisttype *varlist )
 * This function is used to free the variable list created by makelist
 * \param[in] varlist Name of variable list
 */
void freelist( varlisttype *varlist )
{
	varlisttype *varptr,*nextvarptr;

	varptr = varlist;
	while( varptr->next )
	{
		nextvarptr = (varlisttype*)varptr->next;
		mfree(varptr->m_addr);
		free( varptr );
		varptr = nextvarptr;
	}
	free( varptr );
}

#if IO == ON     /* For compilation by the DSP ANSI-C compiler. */
/** \fn void matsave( FILE *fp, matrix *ptm, char mat_name[] )
 * This function is used to save a matrix in a MAT-file, that can be read
 * by MATLAB. The function uses the SAVEMAT.C function provided by MATLAB.
 * The function only handles numrical matrices.
 * \param[in] *fp File pointer to file to save in.
 * \param[in] *ptm Pointer to the matrix that will be saved.
 * \param[in] mat_name String with name of matrix in MATLAB.
 */
void matsave( FILE *fp, matrix *ptm, char mat_name[] )
{

	float *preal,*pimag;
	float *data;
	int type,imagf,mn,i,j,k;

	mn = ptm->row*ptm->col;                       /* Number of data.  */
	data = (float*)malloc(mn*sizeof(float));    /* Allocate buffer. */
	k = 0;

	/* Prepare for SAVEMAT call using MATLAB format. */

	for ( j=0; j < ptm->col; j++ )
	{
		for ( i=0; i < ptm->row; i++ )
		{
			*(data+k) = get_val(ptm,i,j); /* Write to buffer. */
			k++;
		}
	}
	imagf = 0;                  /* No complex data.                   */
	type  = SYSTEM;             /* Only numeric data.                 */
	preal = data;               /* Real data is in buffer "data".     */
	pimag = (float *)0;        /* No complex data.                   */

	savemat(fp,type,mat_name,ptm->row,ptm->col,imagf,preal,pimag);
				    /* Save the matrix in MAT-file.       */
	free(data);                 /* Deallocate buffer memory.          */
}
#endif

#if IO == ON     /* For compilation by the DSP ANSI-C compiler. */
/** \fn void matload( FILE *fp, varlisttype *varlist )
 * This function is used to load matrixes from a MAT-file, that was written
 * by MATLAB. The function uses the LOADMAT.C function provided by MATLAB,
 * but it only handles numerical and real matrices.
 * \param[in]  *fp      File descriptor
 * \param[out] *varlist Pointer to the variable list where the matrix is to be stored.
 *
 * \attention This documentation is not checked for correctness.
 * \todo Sort out the functionality of the function, correct possible errors and redo the documentation.
 */
 // * \param ptm Pointer to the loaded matrix.
 // * \param mat_name String with the name of the matrix to load.

void matload( FILE *fp, varlisttype *varlist )
{

	char name[VARIABLENAMESIZE];
	int found,i,j,k;
	int type,mrows,ncols,imagf;
	float *xr,*xi;
	varlisttype *varptr;
	
	/* Search for the matrix with name in mat_name */
	while( !loadmat(fp,&type,name,&mrows,&ncols,&imagf,&xr,&xi)) 
	{
		printf( "\nSearching for %-20s ..",name );
		varptr = varlist;
		do
		{
			if( !(found = strncmp(varptr->name,name,VARIABLENAMESIZE)) ) /* If found */
			{
				if (imagf) 
				{
					printf("%s\n","Warning from mload :");
					printf("%s\n","The matrix was complex, but the");
					printf("%s\n","imaginary part has been ignored !");
				}

				if ((mrows==0)||(ncols==0)) 
				{ 
					printf("%s\n",name); 
					merror("Matrix was empty error in mload!"); 
				}
				/* Allocate memory for loaded matrix */
				varptr->m_addr = mmake( mrows, ncols );
				varptr->status = FOUND;
				printf( "found" );
				/* Copy data from buffer to matrix using C matrix structure. */
				k = 0;
				for ( j=0; j<ncols; j++ )
				{       
					for ( i=0; i<mrows; i++ )
					{                               
						put_val(varptr->m_addr,i,j,*(xr+k));
						k++;
					}
				}
			}
			varptr = (varlisttype*)varptr->next;
		} while( found!=0 && varptr->next );
		if( found!=0 && (varptr->next==NULL) )
			printf( "NOT found" );
	}
	printf( "\n" );
	fflush( stdout );
}
#endif

/** \fn matrix *mload( char file_name[], char mat_name[] )
 * This function is used to load a matrix from a MAT-file, that was written
 * by MATLAB. The function uses the LOADMAT.C function provided by MATLAB,
 * but it only handles numerical and real matrices.
 * \param[in] file_name String with the name of the MAT-file to read.
 * \param[in] mat_name String with the name of the matrix to load.
 * \return Pointer to the loaded matrix.
 */
matrix *mload( char file_name[], char mat_name[] )
{
#if IO == ON     /* For compilation by the DSP ANSI-C compiler. */

	FILE *fp;
	matrix *ptm;
	char name[VARIABLENAMESIZE];
	int found,i,j,k;
	int type,mrows,ncols,imagf;
	float *xr,*xi;

	fp = fopen(file_name,"rb");        /* Open MAT-file for reading   */
					   /* from the beginning of file. */
	if (!(fp)) 
		merror("File not found error in mload!");

	do  /* Search for the matrix with name in mat_name */
	{
		/* Read the file until matrix is found or EOF is reached. */
		if (loadmat(fp,&type,name,&mrows,&ncols,&imagf,&xr,&xi)) 
		{
			printf("The searched matrix is : %s \n",mat_name);
			merror("matrix not in file error in mload!");
		}

		found = strncmp(mat_name,name,VARIABLENAMESIZE);
	}
	while ( found!=0 );      /* Keep searching until matrix is found. */

	if (imagf) 
	{
		printf("%s\n","Warning from mload :");
		printf("%s\n","The matrix was complex, but the");
		printf("%s\n","imaginary part has been ignored !");
	}

	if ((mrows==0)||(ncols==0)) 
	{ 
		printf("%s\n",name); 
		merror("Matrix was empty error in mload!"); 
	}

	ptm = mmake( mrows, ncols ); /* Allocate memory for loaded matrix */

	/* Copy data from buffer to matrix using C matrix structure. */
	k = 0;
	for ( j=0; j<ncols; j++ )
	{
		for ( i=0; i<mrows; i++ )
		{                               
			put_val(ptm,i,j,*(xr+k));
			k++;
		}
	}

	free(xr);   /* Deallocate data buffers and pointers.*/
	if (imagf) 
		free(xi);
	fclose(fp); /* Close MAT-file.                      */
	return ptm; /* Return pointer to the loaded matrix. */
#else
	file_name=file_name;
	mat_name=mat_name;
	exit(0); /* printf is not available in DSP compiler. */
#endif
}

/** \fn float sload( char file_name[], char scal_name[] )
 * This function loads a scalar (one by one matrix) from a MAT-file.
 * \param[in] file_name Name of MAT-file to search for scalar.
 * \param[in] scal_name Name of Matlab variable in MAT-file.
 * \return The scalar, which was loaded.
 */
float sload( char file_name[], char scal_name[] )
{
#if IO == ON     /* For compilation by the DSP ANSI-C compiler. */

	matrix *ptm;
	float scalar;

	ptm    = mload( file_name, scal_name );
	scalar = ptm->mat[0][0];
	mfree(ptm);

	return scalar;
#else
	file_name=file_name;
	scal_name=scal_name;
	exit(0); /* printf is not available in DSP compiler. */
#endif
}

/** \fn matrix *mlload( varlisttype *varlist, char mat_name[] )
 *This function is used to load a matrix from a variable list,
 * that was created by makelist, and filled by matload
 * \param[in] *varlist Name of variable list
 * \param[in] mat_name String with the name of the matrix to load.
 * \return Pointer to the loaded matrix.
 */
matrix *mlload( varlisttype *varlist, char mat_name[] )
{
#if IO == ON     /* For compilation by the DSP ANSI-C compiler. */
	varlisttype *varptr;
	int found;

	varptr = varlist;
	do  /* Search for the matrix with name in list */
	{
		if( (found=strncmp(mat_name,varptr->name,VARIABLENAMESIZE)) )
			varptr=(varlisttype*)varptr->next;
	}
	while( found!=0 ); /* Keep searching until matrix is found */

	if( varptr->status==NOTFOUND )
	{
		fprintf( stderr,"ERROR: variable '%s' is not in the variablelist\n",mat_name );
		exit( -1 );
	}
	return varptr->m_addr; /* Return pointer to the found matrix. */
#else
	varlist = varlist;
	mat_name=mat_name;
	exit(0); /* printf is not available in DSP compiler. */
#endif
}

/** \fn float slload( varlisttype *varlist, char scal_name[] )
 * This function loads a scalar (one by one matrix) from a varlist.
 * \param[in] *varlist Name of variable list to search for scalar.
 * \param[in] scal_name[] Name of Matlab variable in variable list
 * \return The scalar, which was loaded.
 */
float slload( varlisttype *varlist, char scal_name[] )
{
#if IO == ON     /* For compilation by the DSP ANSI-C compiler. */

	matrix *ptm;
	float scalar;

	ptm    = mlload( varlist, scal_name );
	scalar = ptm->mat[0][0];
	return scalar;
#else
	varlist = varlist;
	scal_name=scal_name;
	exit(0); /* printf is not available in DSP compiler. */
#endif
}


#if IO == ON  /* For compilation by the DSP ANSI-C compiler. */

/** \fn int loadmat(FILE *fp,int *type,char *pname,int *mrows,int *ncols,int *imagf,float **preal,float **pimag)
 * C language routine to load a matrix from a MAT-file.
 *
 * Here is an example that uses 'loadmat' to load a matrix from a MAT-file:
 *
 *      FILE *fp;
 *      char name[VARIABLENAMESIZE];
 *      int type, mrows, ncols, imagf;
 *      float *xr, *xi;
 *      fp = fopen("foo.mat","rb");
 *      loadmat(fp, &type, name, &mrows, &ncols, &imagf, &xr, &xi);
 *      fclose(fp);
 *      free(xr);
 *      if (imagf) free(xi);
 *
 * The 'loadmat' routine returns 0 if the read is successful and 1 if
 * and end-of-file or read error is encountered.  'loadmat' can be called
 * repeatedly until the file is exhausted and an EOF is encountered.
 *
 * Author J.N. Little 11-3-86
 *
 * Modified by Steffen Torp, Servolaboratoriet 14-10-92.
 *
 * \param[in]  *fp File pointer to the desired file
 * \param[in]  *type Type of the variable to get, see reference guide
 * \param[out] *mrows Pointer to row dimension
 * \param[out] *ncols Pointer to column dimension
 * \param[out] *imagf Pointer to imaginary flag
 * \param[out] *pname Pointer to matrix name
 * \param[out] **preal Pointer to real data
 * \param[out] **pimag Pointer to imag data
 * \return 0 on succes an 1 on faliure
 */
int loadmat(FILE *fp,int *type,char *pname,int *mrows,int *ncols,int *imagf,float **preal,float **pimag)
{
	Fmatrix x;
	int mn, namlen, conv;
	

	/*
	 * Get Fmatrix structure from file
	 */
	if (fread((char *)&x, sizeof(Fmatrix), 1, fp) != 1) {
		return(1);
	}


	/* Check if the mat-file is created on a platform similar to */
	/* the actual platform. If yes, the flag 'conv' will be FALSE*/
	/* Otherwise it will be TRUE                                 */

#if SYSTEM==1000           /* OS-9 or UNIX  */
	
		switch (x.type) {
			case 0L:         conv = TRUE;  break;
			case 0x1000000L: conv = TRUE;  break;
			case 1000L:      conv = FALSE; break;
			case 1001L:      conv = FALSE; break;
			default: 
			{
				printf("\nUnknown file type in loadmat!\n");
				printf("The type is: %lx \n",x.type);
				exit(1);
			}
		}
		
#else			/* PC, default  */

		switch (x.type) {
			case 0L:          conv = FALSE; break;
			case 1L:          conv = FALSE; break;
			case 0xE8030000L: conv = TRUE;  break;
			case 0xE9030000L: conv = TRUE;  break;
			default: {
				printf("\nUnknown file type in loadmat!\n");
				printf("The type is: %lx \n",x.type);
				exit(1);
			}
		}
#endif

	if(conv==TRUE)
	{
		*type  = (int)longconv(x.type);
		*mrows = (int)longconv(x.mrows);
		*ncols = (int)longconv(x.ncols);
		*imagf = (int)longconv(x.imagf);
		namlen = (int)longconv(x.namlen);
		mn     = (*mrows)*(*ncols);
	}
	else
	{
		*type  = (int)(x.type);
		*mrows = (int)(x.mrows);
		*ncols = (int)(x.ncols);
		*imagf = (int)(x.imagf);
		namlen = (int)(x.namlen);
		mn     = (*mrows)*(*ncols);
	}
       
	/*
	 * Get matrix name from file
	 */
	if (fread(pname, sizeof(char), namlen, fp) != namlen) {
		return(1);
	}
	
	
	/*
	 * Get Real part of matrix from file
	 */
	if (mn) 
	{
		*preal = (float *)malloc(mn*sizeof(float));
		if (!(*preal)) 
		{
			printf("\nError: Variable too big to load\n");
			return(1);
		}
		if (fread(*preal, sizeof(float), mn, fp) != mn) 
		{
			free(*preal);
			return(1);
		}
		if(conv==TRUE) matconv(mn,*preal);

	}

	/*
	 * Get Imag part of matrix from file, if it exists
	 */
	if (x.imagf) 
	{
		*pimag = (float *)malloc(mn*sizeof(float));
		if (!(*pimag)) 
		{
			printf("\nError: Variable too big to load\n");
			free(*preal);
			return(1);
		}
		if (fread(*pimag, sizeof(float), mn, fp) != mn) 
		{
			free(*pimag);
			free(*preal);
			return(1);
		}
		if(conv==TRUE) 
			matconv(mn,*pimag);
	}
	return(0);
}

/** \fn void savemat(FILE *fp,int type,char *pname,int mrows,int ncols,int imagf,float *preal,float *pimag)
 * savemat - C language routine to save a matrix in a MAT-file.
 *
 * Here is an example that uses 'savemat' to save two matrices to disk,
 * the second of which is complex:
 * \code
 *      FILE *fp;
 *      float xyz[1000], ar[1000], ai[1000];
 *      fp = fopen("foo.mat","wb");
 *      savemat(fp, 2000, "xyz", 2, 3, 0, xyz, (float *)0);
 *      savemat(fp, 2000, "a", 5, 5, 1, ar, ai);
 *      fclose(fp);
 * \endcode
 * 
 * \param[in] *fp File pointer 
 * \param[in] type Type flag: Normally 0 for PC, 1000 for Sun, Mac, and  
 *                Apollo, 2000 for VAX D-float, 3000 for VAX G-float    
 *                Add 1 for text variables.      
 *                See LOAD in reference section of guide for more info. 
 * \param[in] mrows Row dimension 
 * \param[in] ncols Column dimension 
 * \param[in] imagf Imaginary flag 
 * \param[in] *pname Pointer to matrix name 
 * \param[in] *preal Pointer to real data 
 * \param[in] *pimag Pointer to imag data 
 *
 * \author J.N. Little 
 * \date 11-3-86
 */
void savemat(FILE *fp,int type,char *pname,int mrows,int ncols,int imagf,float *preal,float *pimag)
{
	Fmatrix x;
	int mn;
	
	x.type   = (long)type;
	x.mrows  = (long)mrows;
	x.ncols  = (long)ncols;
	x.imagf  = (long)imagf;
	x.namlen = (long)strlen(pname) + 1L;
	mn       = (int)(x.mrows * x.ncols);

	fwrite(&x, sizeof(Fmatrix), 1, fp);
	fwrite(pname, sizeof(char), (int)x.namlen, fp);
	fwrite(preal, sizeof(float), mn, fp);
	if (imagf) 
	     fwrite(pimag, sizeof(float), mn, fp);
}

/** \fn long longconv( long inval ) 
 * This function flips long integers, in order to convert longs
 * from INTEL to MOTOROLA format or vice versa.
 * (Internal function only)
 *
 * \param[in] inval Long integer to be converted
 * \return The converted long.
 */
long longconv( long inval )
{
	char *ptc1, *ptc2;
	long outval;
	ptc1=(char*)(&inval);
	ptc2=(char*)(&outval);
	*(ptc2)=*(ptc1+3);
	*(ptc2+1)=*(ptc1+2);
	*(ptc2+2)=*(ptc1+1);
	*(ptc2+3)=*(ptc1);
	return( outval );
}

/** \fn void matconv( int mn, float *ptd ) 
 * This function flips a number of floats, in a consecutive part 
 * of the memory, in order to convert matrix data from INTEL to  
 * MOTOROLA format or vice versa.
 * (Internal function only)
 *
 * \param[in] mn Number of elements in the matrix
 * \param[in] *ptd Pointer to the first element
 */
 void matconv( int mn, float *ptd )
{
	char *ptc1, *ptc2;
	float tmp;
// 	int i, j;
	int k;
	for( k=0;k<mn;k++ )
	{
		/* Flip the k'th float */
		tmp = *(ptd+k);
		ptc1=(char*)(ptd+k);
		ptc2=(char*)&tmp;
		*ptc1=*(ptc2+7);
		*(ptc1+1)=*(ptc2+6);
		*(ptc1+2)=*(ptc2+5);
		*(ptc1+3)=*(ptc2+4);
		*(ptc1+4)=*(ptc2+3);
		*(ptc1+5)=*(ptc2+2);
		*(ptc1+6)=*(ptc2+1);
		*(ptc1+7)=*ptc2;
	}
}


#endif /* I/O functions are not available in the DSP compiler. */

